#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h>
#include <sys/ioctl.h>
#include <dirent.h>
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <time.h>

#define 	LOW(x)			((x) & 0xFF)
#define 	HIGH(x)			(((x) >> 8) & 0xFF)
/*
Bytes   Content
0-2     Jump to bootstrap (E.g. eb 3c 90; on i86: JMP 003E NOP.			0xEB,0x3C,0x90
        One finds either eb xx 90, or e9 xx xx.
        The position of the bootstrap varies.)
3-10    OEM name/version (E.g. "IBM  3.3", "IBM 20.0", "MSDOS5.0", "MSWIN4.0".	0x4D,0x53,0x44,0x4F,0x53,0x35,0x2E,0x30,
        Various format utilities leave their own name, like "CH-FOR18".
        Sometimes just garbage. Microsoft recommends "MSWIN4.1".)
         BIOS Parameter Block starts here 
11-12   Number of bytes per sector (512)					0x00,0x02 = 512
        Must be one of 512, 1024, 2048, 4096.
13      Number of sectors per cluster (1)					0x08 = 8
        Must be one of 1, 2, 4, 8, 16, 32, 64, 128.
        A cluster should have at most 32768 bytes. In rare cases 65536 is OK.
14-15   Number of reserved sectors (1)						0x01,0x00 = 1
        FAT12 and FAT16 use 1. FAT32 uses 32.
16      Number of FAT copies (2)						0x02 = 2
17-18   Number of root directory entries (224)					0x00,0x02 = 512
        0 for FAT32. 512 is recommended for FAT16.
19-20   Total number of sectors in the filesystem (2880)			0x00,0x70 = 28672 (0x38 0x28 ) = 10296 DISK_LAST_SECTOR+1
        (in case the partition is not FAT32 and smaller than 32 MB)
21      Media descriptor type (f0: 1.4 MB floppy, f8: hard disk; see below)	0xF8
22-23   Number of sectors per FAT (9)						0x0B,0x00 = 11
        0 for FAT32.
24-25   Number of sectors per track (12)					0x3F,0x00 = 63
26-27   Number of heads (2, for a double-sided diskette)			0xFF,0x00 = 255

 1.2.3 FAT16 
FAT16 uses the above BIOS Parameter Block, with some extensions: 

11-27   (as before)
28-31   Number of hidden sectors (0)						0x00,0x00,0x00,0x00
32-35   Total number of sectors in the filesystem				0x00,0x00,0x00,0x00
        (in case the total was not given in bytes 19-20)
36      Logical Drive Number (for use with INT 13, e.g. 0 or 0x80)		0x00
37      Reserved (Earlier: Current Head, the track containing the Boot Record)	0x00
        Used by Windows NT: bit 0: need disk check; bit 1: need surface scan
38      Extended signature (0x29)						0x29
        Indicates that the three following fields are present.
        Windows NT recognizes either 0x28 or 0x29.
39-42   Serial number of partition						0x8F,0x08,0x77,0xFE
43-53   Volume label or "NO NAME    "						0x4E,0x4F,0x20,0x4E,0x41,0x4D,0x45,0x20,0x20,0x20,0x20
54-61   Filesystem type (E.g. "FAT12   ", "FAT16   ", "FAT     ", or all zero.)	0x46,0x41,0x54,0x31,0x32,0x20,0x20,0x20
62-509  Bootstrap
510-511 Signature 55 aa	
*/
/* Usb ram disk info */

/*usb disk configuration */
#define 	DIRECTORYENTRY		(512)
#define 	SECTORSIZE			0x200
#define  CLUSTERSIZE			0x08
#define	BOOTSECTOR			1

#define 	RAMDISKSIZE			(0x00100000 + (SECTORSIZE*CLUSTERSIZE))


#define	DIRECTORYSECTOR	((DIRECTORYENTRY * 32) / SECTORSIZE)
#define	FATSECTOR			(((RAMDISKSIZE*3) / (SECTORSIZE * SECTORSIZE * CLUSTERSIZE * 2)) + 1)
#define 	DATAOFFSET			((BOOTSECTOR + (FATSECTOR * 2) + DIRECTORYSECTOR) * SECTORSIZE)
//#define 	DATAOFFSET			0x00006E00
#define 	DISK_LAST_SECTOR	(((RAMDISKSIZE + DATAOFFSET)/ SECTORSIZE) + 1)		/* last sector of a 5M disk (5271552octets)*/
#if (DISK_LAST_SECTOR > 0xFFFF)
#ERR  (too much sectors)
#endif

#define 	DISK_DATA_START		(USB_DISK_START + DATAOFFSET)		/* last sector of a 5M disk (5271552octets)*/

#define 	DIROFFSET			((BOOTSECTOR + (FATSECTOR * 2) ) * SECTORSIZE)



unsigned char bootSector[512] = {
	0xEB,0x3C,0x90, 'M', 'S', 'D', 'O', 'S', '5', '.', '0',0x00,0x02,0x08,0x01,0x00,
	0x02,LOW(DIRECTORYENTRY),HIGH(DIRECTORYENTRY),LOW(DISK_LAST_SECTOR+1),HIGH(DISK_LAST_SECTOR+1),
				 0xF8,LOW(FATSECTOR),HIGH(FATSECTOR),0x3F,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,
//	0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x8F,0x08,0x77,0xFE, 'N', 'O', ' ', 'N', 'A',
//	 'M', 'E', ' ', ' ', ' ', ' ', 'F', 'A' ,'T', '1', '2', ' ', ' ', ' ',0x33,0xC9,
	0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x8F,0x08,0x77,0xFE,0x50,0x43,0x4D,0x5F,0x44,
	0x55,0x54,0x20,0x20,0x20,0x20, 'F', 'A' ,'T', '1', '2', ' ', ' ', ' ',0x33,0xC9,				 
	0x8E,0xD1,0xBC,0xF0,0x7B,0x8E,0xD9,0xB8,0x00,0x20,0x8E,0xC0,0xFC,0xBD,0x00,0x7C,
	0x38,0x4E,0x24,0x7D,0x24,0x8B,0xC1,0x99,0xE8,0x3C,0x01,0x72,0x1C,0x83,0xEB,0x3A,
	0x66,0xA1,0x1C,0x7C,0x26,0x66,0x3B,0x07,0x26,0x8A,0x57,0xFC,0x75,0x06,0x80,0xCA,
	0x02,0x88,0x56,0x02,0x80,0xC3,0x10,0x73,0xEB,0x33,0xC9,0x8A,0x46,0x10,0x98,0xF7,
	0x66,0x16,0x03,0x46,0x1C,0x13,0x56,0x1E,0x03,0x46,0x0E,0x13,0xD1,0x8B,0x76,0x11,
	0x60,0x89,0x46,0xFC,0x89,0x56,0xFE,0xB8,0x20,0x00,0xF7,0xE6,0x8B,0x5E,0x0B,0x03,
	0xC3,0x48,0xF7,0xF3,0x01,0x46,0xFC,0x11,0x4E,0xFE,0x61,0xBF,0x00,0x00,0xE8,0xE6,
	0x00,0x72,0x39,0x26,0x38,0x2D,0x74,0x17,0x60,0xB1,0x0B,0xBE,0xA1,0x7D,0xF3,0xA6,
	0x61,0x74,0x32,0x4E,0x74,0x09,0x83,0xC7,0x20,0x3B,0xFB,0x72,0xE6,0xEB,0xDC,0xA0,
	0xFB,0x7D,0xB4,0x7D,0x8B,0xF0,0xAC,0x98,0x40,0x74,0x0C,0x48,0x74,0x13,0xB4,0x0E,
	0xBB,0x07,0x00,0xCD,0x10,0xEB,0xEF,0xA0,0xFD,0x7D,0xEB,0xE6,0xA0,0xFC,0x7D,0xEB,
	0xE1,0xCD,0x16,0xCD,0x19,0x26,0x8B,0x55,0x1A,0x52,0xB0,0x01,0xBB,0x00,0x00,0xE8,
	0x3B,0x00,0x72,0xE8,0x5B,0x8A,0x56,0x24,0xBE,0x0B,0x7C,0x8B,0xFC,0xC7,0x46,0xF0,
	0x3D,0x7D,0xC7,0x46,0xF4,0x29,0x7D,0x8C,0xD9,0x89,0x4E,0xF2,0x89,0x4E,0xF6,0xC6,
	0x06,0x96,0x7D,0xCB,0xEA,0x03,0x00,0x00,0x20,0x0F,0xB6,0xC8,0x66,0x8B,0x46,0xF8,
	0x66,0x03,0x46,0x1C,0x66,0x8B,0xD0,0x66,0xC1,0xEA,0x10,0xEB,0x5E,0x0F,0xB6,0xC8,
	0x4A,0x4A,0x8A,0x46,0x0D,0x32,0xE4,0xF7,0xE2,0x03,0x46,0xFC,0x13,0x56,0xFE,0xEB,
	0x4A,0x52,0x50,0x06,0x53,0x6A,0x01,0x6A,0x10,0x91,0x8B,0x46,0x18,0x96,0x92,0x33,
	0xD2,0xF7,0xF6,0x91,0xF7,0xF6,0x42,0x87,0xCA,0xF7,0x76,0x1A,0x8A,0xF2,0x8A,0xE8,
	0xC0,0xCC,0x02,0x0A,0xCC,0xB8,0x01,0x02,0x80,0x7E,0x02,0x0E,0x75,0x04,0xB4,0x42,
	0x8B,0xF4,0x8A,0x56,0x24,0xCD,0x13,0x61,0x61,0x72,0x0B,0x40,0x75,0x01,0x42,0x03,
	0x5E,0x0B,0x49,0x75,0x06,0xF8,0xC3,0x41,0xBB,0x00,0x00,0x60,0x66,0x6A,0x00,0xEB,
	0xB0,0x4E,0x54,0x4C,0x44,0x52,0x20,0x20,0x20,0x20,0x20,0x20,0x0D,0x0A,0x4E,0x54,
	0x4C,0x44,0x52,0x20,0x69,0x73,0x20,0x6D,0x69,0x73,0x73,0x69,0x6E,0x67,0xFF,0x0D,
	0x0A,0x44,0x69,0x73,0x6B,0x20,0x65,0x72,0x72,0x6F,0x72,0xFF,0x0D,0x0A,0x50,0x72,
	0x65,0x73,0x73,0x20,0x61,0x6E,0x79,0x20,0x6B,0x65,0x79,0x20,0x74,0x6F,0x20,0x72,
	0x65,0x73,0x74,0x61,0x72,0x74,0x0D,0x0A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xAC,0xBF,0xCC,0x55,0xAA
	};

void formatDrive(char * filename)
{
	int	i, j, k;
	int len;
	int total =0;
	unsigned char sector[SECTORSIZE];
	int fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC);
	printf("create disk usb %d\n", fd);
	if (fd > 0) {
		k = 0;
		// write boot sector
		printf("create disk boot sector\n");
		for (i=0; i<SECTORSIZE; i++)
		{
			sector[i] = bootSector[i];
		}
		len = write(fd, sector, sizeof(sector));
		if (len > 0 )
			total += len;
		else
			printf("error %d %d \n", len ,k);
		k++;
		// write FAT (2 copies) 2*(11)secteurs
		printf("create disk FAT (2 copies) %d len 0x%08x\n", k, total);
		for (i=0; i<2; i++)
		{
			sector[0] = 0xF8;
			sector[1] = 0xFF;
			sector[2] = 0xFF;
			for (j = 3; j < SECTORSIZE; j++)
				sector[j] = 0;
			len = write(fd, sector, sizeof(sector));
			if (len > 0 )
				total += len;
			else
				printf("error %d %d \n", len ,k);
			k++;
			memset(sector, 0, sizeof(sector));
			for (j = 1; j < FATSECTOR; j++) {
				len = write(fd, sector, sizeof(sector));
				if (len >0 )
					total += len;
				else
					printf("error %d %d \n", len ,k);
				k++;
			}
		}
		memset(sector, 0, sizeof(sector));
	
		// write directory entries 32 secteurs
		printf("create disk directory entries %d len 0x%08x\n", k, total);
		for (i=0; i < DIRECTORYSECTOR; i++) {
			len = write(fd, sector, sizeof(sector));
			if (len >0 )
				total += len;
			else
				printf("error %d %d \n", len ,k);
			k++;
		}
		// write data
		printf("create disk data %d len 0x%08x\n", k, total);
		for (i= (BOOTSECTOR + (FATSECTOR * 2) + DIRECTORYSECTOR); i < DISK_LAST_SECTOR; i++) {
			len = write(fd, sector, sizeof(sector));
			/*if (!(i %32 ))
				printf("sector %d %d \n", len ,k);*/
			if (len > 0 )
				total += len;
			else
				printf("error %d %d \n", len ,k);
			k++;
		}
		close (fd);
		printf("nombre de secteur  %d len 0x%08x\n", k, total);
	}
}

